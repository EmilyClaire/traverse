<!DOCTYPE HTML>
<html>
  <head>
    <title>WebGL/Three.js Light Tutorial</title>
    <style>
      body {
        background: linear-gradient(#e4e0ba, black);
        margin: 0px;
        overflow: hidden;
       
      }
      #wordart{
        width:1024;
        height:1024;
        display:none;
      }

    </style>
  </head>
  <body>
    <canvas id='wordart'></canvas>
    <script src="/../three.js/build/three.min.js"></script>
    <script src="/../three.js/examples/js/controls/OrbitControls.js"></script>

  
    <script>
        var camera;
        var scene;
        var renderer;
        var controls;
        init();
        animate();
          
        function init() {
          
            // Create a scene
            scene = new THREE.Scene();
          
            // Add the camera
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(20,-200,300);
          
            // Add scene elements
            addSceneElements();
            var paths=[[0,0,0,.5,.6,.4,.5,.1,.9],
                        [.2,.3,.9,.2,.6,.1,.1,.2,.3],
                        [.4,.5,.1,.7,.9,.2,.3,.5,.4],
                        [.9,.8,.2,.3,.6,.8,1,.5,.4],
                        [1,1,1,1,1,1,1,1,1],
                        [.3,.5,.4,.8,.9,.3,.3,.5,.4],
                        [.9,.8,.1,.3,.6,.7,1,.5,.4],
                        [1,1,1,1,.5,.4,.1,.7,.9],
                        [.9,.9,.7,.3,.7,.7,1,.5,.4]] 
                // var paths=[[1,.5],
                //             [0,1],
                //             [.5,.5]
                //         ] 
            generateTexture(paths);
            //scene.add(mkTerrain())
            // Add lights
            addLights();

            addPlane(paths);
          
            // Create the WebGL Renderer
            renderer = new THREE.WebGLRenderer({alpha: true});
            renderer.setSize( window.innerWidth, window.innerHeight );
          
            // Append the renderer to the body
            document.body.appendChild( renderer.domElement );
          
            // Add a resize event listener
            window.addEventListener( 'resize', onWindowResize, false );
          
            // Add the orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target = new THREE.Vector3(0, 100, 0);

        }
          
       
        function addLights(){
            var dirLight = new THREE.DirectionalLight('0xffffff', .5);
            dirLight.position.set(20,-200,300);
            scene.add(dirLight);
        }
        function addSceneElements() { 
            var geometry = new THREE.SphereGeometry( 5, 400, 400);
            var material = new THREE.MeshBasicMaterial( {wireframe:true,color: 0xffff00} );
            var sphere = new THREE.Mesh( geometry, material );
            //scene.add( sphere );

        }
        function nearestPowerOf2(num){
            //not optimal!!
            var current=2;
            while(current<num){
                current=current*2;
            }
            return current;
        }

        function mkTerrain() {
            //needs to be a rectangle
            //ideally a square whose side is power of 2
            paths=new Float32Array([
                1,0.2,1,1,
                0,0,0,0,
                1,1,0.4,1,
                0,0,0,0
            ])
            //assuming it's a square
            var size=Math.sqrt(paths.length);
            map = new THREE.DataTexture(paths,
                size, size,
                THREE.AlphaFormat,
                THREE.FloatType );
            map.needsUpdate = true;

            material = new THREE.ShaderMaterial({
                uniforms: {
                    map: {
                        type: "t",
                        value: map
                    }
                },
                vertexShader:
`
uniform sampler2D map;
varying float height;
uniform vec2 myTexResolution;



float random(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float getDisplacement() {
    float tex = texture2D(map, uv).a;
    for (int i = 0; i < 100; ++i) {
        tex += texture2D(map, uv + vec2(
            0.25 * random(vec2(float(i), uv.x)),
            0.25 * random(vec2(float(i), uv.y)))).a;
    }
    // float point = 0.1;
    // tex += texture2D(map, uv + vec2(point, point));
    // tex += texture2D(map, uv + vec2(-point, point));
    // tex += texture2D(map, uv + vec2(point, -point));
    // tex += texture2D(map, uv + vec2(-point, -point));
    // tex += texture2D(map, uv + vec2(0, -point));
    // tex += texture2D(map, uv + vec2(0, point));
    // tex += texture2D(map, uv + vec2(point, 0));
    // tex += texture2D(map, uv + vec2(-point, 0));
    // tex = tex / 9.0;
    return tex / 100.0;
}

/**
 * Multiply each vertex by the
 * model-view matrix and the
 * projection matrix (both provided
 * by Three.js) to get a final
 * vertex position
 */
void main() {
    height = getDisplacement(); //texture2D(map, uv).a;
    vec3 new_pos = vec3(position.x, position.y, position.z + height * 100.0);
  gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(new_pos,1.0);
}`,

                fragmentShader:
`/**
 * Set the colour to a lovely pink.
 * Note that the color is a 4D Float
 * Vector, R,G,B and A and each part
 * runs from 0.0 to 1.0
 */

 varying float height;
void main() {
  gl_FragColor = vec4(1.0,  // R
                      height,  // G
                      1.0,  // B
                      1.0); // A
}`,
            })
            var geometry = new THREE.PlaneBufferGeometry(400, 400, 256, 256);
            mesh = new THREE.Mesh( geometry, material );
            return mesh
        }



        function generateTexture(paths) {
            //make proportional to width and height
            // var textureWidth = paths[0].length;
            // var textureHeight = paths.length;
            var textureWidth = nearestPowerOf2(paths[0].length);
            var textureHeight = nearestPowerOf2(paths.length);
            var geometry = new THREE.PlaneBufferGeometry( 200, 200, 32, 32);
            //sphere = new THREE.SphereGeometry( 6, 400, 400 );

            var size = textureWidth * textureHeight;
            var dataColor = new Uint8Array( size * 3 );
            //fill in with blue, for reference
            for(var i=0;i<size;i++){
                dataColor[ i * 3 ]     = 0;
                dataColor[ i * 3 + 1 ] = 0;
                dataColor[ i * 3 + 2 ] = 255;               
            }

            //fill with actual values
            var index=0;
            var intensity;
            var padding;
            for(var i=0;i<paths.length;i++){
                console.log(paths);
                for(var j=0;j<paths[0].length;j++){
                    intensity=Math.floor(paths[i][j]*255);
                    console.log('dealing with val '+paths[i][j]+' at index '+index);
                    dataColor[ index * 3 ]     = intensity;
                    dataColor[ index * 3 + 1 ] = intensity;
                    dataColor[ index * 3 + 2 ] = intensity;
                    index++;
                }
                padding=textureWidth-paths[0].length;
                index+=padding;
            }
            //console.log(dataColor);
            map = new THREE.DataTexture(dataColor, textureWidth, textureHeight, THREE.RGBFormat );
            map.needsUpdate = true;

            material = new THREE.MeshBasicMaterial( { wireframe: false, map: map} )
            mesh = new THREE.Mesh( geometry, material );
            //mesh.scale.x = -1;
            //scene.add( mesh );
            //console.log(camera.position);
            //console.log(mesh.position);


        }

        function magnifyArray(arr, scale) {
            var res = [];
            if(!arr.length)
                return arr;
            for (var i = 0; i < arr.length; i++) {
                var temp = magnifyArray(arr[i], scale);
                for (var k = 0; k < scale; k++) {
                    res.push(temp.slice ? temp.slice(0) : temp);
                }
            }
            return res;
        }
  

        function addPlane(paths){
            // var wS=199;
            // var hS=199;
            // var geometry = new THREE.PlaneGeometry(paths.length*10,paths[0].length*10, wS, hS);
            // var material = new THREE.MeshPhongMaterial({
            //     wireframe: true
            // });
            // console.log(geometry.vertices.length);

            // // for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            // //   geometry.vertices[i].z = paths[i] / 65535 * 10;
            // // }
            // var xCoord;
            // var yCoord;
            // var pathsX;
            // var pathsY;
            // console.log(geometry.vertices.length);
            // for(var i=0; i<geometry.vertices.length; i++){
            //     // console.log(i);
            //     xCoord=i%wS;
            //     yCoord=Math.floor(i/hS);
            //     // console.log('xCoord',xCoord);
            //     // console.log('yCoord',yCoord);
            //     pathsX=Math.floor((xCoord/wS)*paths[0].length);
            //     // console.log('pathsX',pathsX);
            //     pathsY=Math.floor((yCoord/hS)*paths.length);
            //     // console.log('pathsY',pathsY);
            //     if(paths[pathsX]&&paths[pathsY]){
            //         geometry.vertices[i].z =  paths[pathsX][pathsY]*10;
            //     }
            // }
            var scaleUp=4;
            var wS=(paths[0].length*scaleUp)-1;
            var hS=(paths.length*scaleUp)-1;
            var geometry = new THREE.PlaneGeometry(paths.length*10,paths[0].length*10, wS, hS);
            var material = new THREE.MeshPhongMaterial({
                shininess: 20,
                color: 'red',
                wireframe: true 
            });

            // for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            //   geometry.vertices[i].z = paths[i] / 65535 * 10;
            // }
            var xCoord;
            var yCoord;
            var pathsX;
            var pathsY;

            var valToPush;

            var radius=2;
            var distance;
            var scaledArr=magnifyArray(paths,scaleUp);
            console.log(scaledArr);
            var neighbors;
            var newVal;
            var smoothedArr=[];
            for(var r=0;r<scaledArr.length;r++){
                for(var c=0;c<scaledArr[0].length;c++){
                    neighbors=[];
                    for(var i=-radius;i<radius;i++){
                        for(var j=-radius;j<radius;j++){
                            if(i===0&&j===0){
                                neighbors.push(scaledArr[r][c]*10)
                            }
                            else if(scaledArr[r+i]&&scaledArr[r+i][c+j]){
                                distance=Math.sqrt(Math.pow(i,2)+j**2);
                                console.log('distance',distance)
                                neighbors.push(scaledArr[r+i][c+j]*(1/Math.pow(distance,2)));
                            }
                        }
                    }
                    newVal=findMean(neighbors);
                    if(!smoothedArr[r]){
                        smoothedArr[r]=[];
                    }
                    smoothedArr[r][c]=newVal;
                }

            }
            var flattenedArr=[];
            for(var i=0;i<smoothedArr.length;i++){
                flattenedArr=flattenedArr.concat(smoothedArr[i]);
            }
            console.log('flattenedArr',flattenedArr);
            for(var i=0; i<geometry.vertices.length; i++){
                geometry.vertices[i].z =  flattenedArr[i]*10;
            }
            var plane = new THREE.Mesh(geometry, material);
            scene.add(plane);
        }
        function findMean(arr){
            var sum=0;
            arr.forEach(function(item){
                sum+=item;
            })
            return sum/arr.length;
        }

        function animate() {
            renderer.render( scene, camera );
            requestAnimationFrame( animate );
            controls.update();
        }
          
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
    </script>
  </body>
</html>