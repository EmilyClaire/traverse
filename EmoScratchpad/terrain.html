<!DOCTYPE HTML>
<html>
  <head>
    <title>WebGL/Three.js Light Tutorial</title>
    <style>
      body {
        background: linear-gradient(#e4e0ba, black);
        margin: 0px;
        overflow: hidden;
       
      }
      #wordart{
        width:1024;
        height:1024;
        display:none;
      }

    </style>
  </head>
  <body>
    <canvas id='wordart'></canvas>
    <script src="/../three.js/build/three.min.js"></script>
    <script src="/../three.js/examples/js/controls/OrbitControls.js"></script>

  
    <script>
        var camera;
        var scene;
        var renderer;
        var controls;
        init();
        animate();
          
        function init() {
          
            // Create a scene
            scene = new THREE.Scene();
          
            // Add the camera
            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0,0,200);
          
            // Add scene elements
            addSceneElements();
            // var paths=[[0,0,0,.5,.6,.4,.5,.1,.9],
            //             [.2,.3,.9,.2,.6,.1,.1,.2,.3],
            //             [.4,.5,.1,.7,.9,.2,.3,.5,.4],
            //             [.9,.8,.2,.3,.6,.8,1,.5,.4],
            //             [1,1,1,1,1,1,1,1,1],
            //             [.3,.5,.4,.8,.9,.3,.3,.5,.4],
            //             [.9,.8,.1,.3,.6,.7,1,.5,.4],
            //             [1,1,1,1,.5,.4,.1,.7,.9],
            //             [.9,.9,.7,.3,.7,.7,1,.5,.4]] 
                var paths=[[1,1,1],
                            [0,0,0],
                            [1,1,1]
                        ] 
            //generateTexture(paths);
              scene.add(mkTerrain())
            // Add lights
            // addLights();

            //addPlane(paths);
          
            // Create the WebGL Renderer
            renderer = new THREE.WebGLRenderer({alpha: true});
            renderer.setSize( window.innerWidth, window.innerHeight );
          
            // Append the renderer to the body
            document.body.appendChild( renderer.domElement );
          
            // Add a resize event listener
            window.addEventListener( 'resize', onWindowResize, false );
          
            // Add the orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target = new THREE.Vector3(0, 100, 0);

        }
          
       
        function addLights(){
            var ambLight = new THREE.AmbientLight('0x404040');
            scene.add(ambLight);
        }
        function addSceneElements() { 
            var geometry = new THREE.SphereGeometry( 5, 400, 400);
            var material = new THREE.MeshBasicMaterial( {wireframe:true,color: 0xffff00} );
            var sphere = new THREE.Mesh( geometry, material );
            //scene.add( sphere );

        }
        function nearestPowerOf2(num){
            //not optimal!!
            var current=2;
            while(current<num){
                current=current*2;
            }
            return current;
        }

        function mkTerrain() {
            //needs to be a rectangle
            //ideally a square whose side is power of 2
            paths=new Float32Array([
                1,0.2,1,1,
                0,0,0,0,
                1,1,0.4,1,
                0,0,0,0
            ])
            //assuming it's a square
            var size=Math.sqrt(paths.length);
            map = new THREE.DataTexture(paths,
                size, size,
                THREE.AlphaFormat,
                THREE.FloatType );
            map.needsUpdate = true;

            material = new THREE.ShaderMaterial({
                uniforms: {
                    map: {
                        type: "t",
                        value: map
                    }
                },
                vertexShader:
`
uniform sampler2D map;
varying float height;
uniform vec2 myTexResolution;



float random(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float getDisplacement() {
    float tex = texture2D(map, uv).a;
    for (int i = 0; i < 100; ++i) {
        tex += texture2D(map, uv + vec2(
            0.25 * random(vec2(float(i), uv.x)),
            0.25 * random(vec2(float(i), uv.y)))).a;
    }
    // float point = 0.1;
    // tex += texture2D(map, uv + vec2(point, point));
    // tex += texture2D(map, uv + vec2(-point, point));
    // tex += texture2D(map, uv + vec2(point, -point));
    // tex += texture2D(map, uv + vec2(-point, -point));
    // tex += texture2D(map, uv + vec2(0, -point));
    // tex += texture2D(map, uv + vec2(0, point));
    // tex += texture2D(map, uv + vec2(point, 0));
    // tex += texture2D(map, uv + vec2(-point, 0));
    // tex = tex / 9.0;
    return tex / 100.0;
}

/**
 * Multiply each vertex by the
 * model-view matrix and the
 * projection matrix (both provided
 * by Three.js) to get a final
 * vertex position
 */
void main() {
    height = getDisplacement(); //texture2D(map, uv).a;
    vec3 new_pos = vec3(position.x, position.y, position.z + height * 100.0);
  gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(new_pos,1.0);
}`,

                fragmentShader:
`/**
 * Set the colour to a lovely pink.
 * Note that the color is a 4D Float
 * Vector, R,G,B and A and each part
 * runs from 0.0 to 1.0
 */

 varying float height;
void main() {
  gl_FragColor = vec4(1.0,  // R
                      height,  // G
                      1.0,  // B
                      1.0); // A
}`,
            })
            var geometry = new THREE.PlaneBufferGeometry(400, 400, 256, 256);
            mesh = new THREE.Mesh( geometry, material );
            return mesh
        }

        function generateTexture(paths) {
            //make proportional to width and height
            // var textureWidth = paths[0].length;
            // var textureHeight = paths.length;
            var textureWidth = nearestPowerOf2(paths[0].length);
            var textureHeight = nearestPowerOf2(paths.length);
            var geometry = new THREE.PlaneBufferGeometry( 200, 200, 32, 32);
            //sphere = new THREE.SphereGeometry( 6, 400, 400 );

            var size = textureWidth * textureHeight;
            var dataColor = new Uint8Array( size * 3 );
            //fill in with blue, for reference
            for(var i=0;i<size;i++){
                dataColor[ i * 3 ]     = 0;
                dataColor[ i * 3 + 1 ] = 0;
                dataColor[ i * 3 + 2 ] = 255;               
            }

            //fill with actual values
            var index=0;
            var intensity;
            var padding;
            for(var i=0;i<paths.length;i++){
                console.log(paths);
                for(var j=0;j<paths[0].length;j++){
                    intensity=Math.floor(paths[i][j]*255);
                    console.log('dealing with val '+paths[i][j]+' at index '+index);
                    dataColor[ index * 3 ]     = intensity;
                    dataColor[ index * 3 + 1 ] = intensity;
                    dataColor[ index * 3 + 2 ] = intensity;
                    index++;
                }
                padding=textureWidth-paths[0].length;
                index+=padding;
            }
            console.log(dataColor);
            map = new THREE.DataTexture(dataColor, textureWidth, textureHeight, THREE.RGBFormat );
            map.needsUpdate = true;

            material = new THREE.MeshBasicMaterial( { wireframe: false, map: map} )
            mesh = new THREE.Mesh( geometry, material );
            //mesh.scale.x = -1;
            scene.add( mesh );
            console.log(camera.position);
            console.log(mesh.position);


        }
        function addPlane(paths){
            var wS=199;
            var hS=199;
            var geometry = new THREE.PlaneGeometry(paths.length*10,paths[0].length*10, wS, hS);
            var material = new THREE.MeshPhongMaterial({
                color: 0xdddddd, 
                wireframe: true
            });
            console.log(geometry.vertices.length);

            // for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            //   geometry.vertices[i].z = paths[i] / 65535 * 10;
            // }
            var xCoord;
            var yCoord;
            var pathsX;
            var pathsY;
            for(var i=0; i<geometry.vertices.length; i++){
                // console.log(i);
                xCoord=i%wS;
                yCoord=Math.floor(i/hS);
                // console.log('xCoord',xCoord);
                // console.log('yCoord',yCoord);
                pathsX=Math.floor((xCoord/wS)*paths[0].length);
                // console.log('pathsX',pathsX);
                pathsY=Math.floor((yCoord/hS)*paths.length);
                // console.log('pathsY',pathsY);
                if(paths[pathsX]&&paths[pathsY]){
                    geometry.vertices[i].z =  paths[pathsX][pathsY]*10;
                }
            }

            // for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            //     if(paths[i]){
            //         paths[i];
            //         geometry.vertices[i].z =  paths[i]*10;
            //     }
            // }

            var plane = new THREE.Mesh(geometry, material);
            scene.add(plane);
        }
        function animate() {
            renderer.render( scene, camera );
            requestAnimationFrame( animate );
            controls.update();
        }
          
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
    </script>
  </body>
</html>